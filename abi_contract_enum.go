// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package eth

import (
	"fmt"
	"strings"
)

const (
	// DeclarationTypeFunction is a DeclarationType of type Function.
	DeclarationTypeFunction DeclarationType = iota
	// DeclarationTypeConstructor is a DeclarationType of type Constructor.
	DeclarationTypeConstructor
	// DeclarationTypeReceive is a DeclarationType of type Receive.
	DeclarationTypeReceive
	// DeclarationTypeFallback is a DeclarationType of type Fallback.
	DeclarationTypeFallback
	// DeclarationTypeEvent is a DeclarationType of type Event.
	DeclarationTypeEvent
	// DeclarationTypeError is a DeclarationType of type Error.
	DeclarationTypeError
)

const _DeclarationTypeName = "FunctionConstructorReceiveFallbackEventError"

var _DeclarationTypeNames = []string{
	_DeclarationTypeName[0:8],
	_DeclarationTypeName[8:19],
	_DeclarationTypeName[19:26],
	_DeclarationTypeName[26:34],
	_DeclarationTypeName[34:39],
	_DeclarationTypeName[39:44],
}

// DeclarationTypeNames returns a list of possible string values of DeclarationType.
func DeclarationTypeNames() []string {
	tmp := make([]string, len(_DeclarationTypeNames))
	copy(tmp, _DeclarationTypeNames)
	return tmp
}

var _DeclarationTypeMap = map[DeclarationType]string{
	DeclarationTypeFunction:    _DeclarationTypeName[0:8],
	DeclarationTypeConstructor: _DeclarationTypeName[8:19],
	DeclarationTypeReceive:     _DeclarationTypeName[19:26],
	DeclarationTypeFallback:    _DeclarationTypeName[26:34],
	DeclarationTypeEvent:       _DeclarationTypeName[34:39],
	DeclarationTypeError:       _DeclarationTypeName[39:44],
}

// String implements the Stringer interface.
func (x DeclarationType) String() string {
	if str, ok := _DeclarationTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("DeclarationType(%d)", x)
}

var _DeclarationTypeValue = map[string]DeclarationType{
	_DeclarationTypeName[0:8]:                    DeclarationTypeFunction,
	strings.ToLower(_DeclarationTypeName[0:8]):   DeclarationTypeFunction,
	_DeclarationTypeName[8:19]:                   DeclarationTypeConstructor,
	strings.ToLower(_DeclarationTypeName[8:19]):  DeclarationTypeConstructor,
	_DeclarationTypeName[19:26]:                  DeclarationTypeReceive,
	strings.ToLower(_DeclarationTypeName[19:26]): DeclarationTypeReceive,
	_DeclarationTypeName[26:34]:                  DeclarationTypeFallback,
	strings.ToLower(_DeclarationTypeName[26:34]): DeclarationTypeFallback,
	_DeclarationTypeName[34:39]:                  DeclarationTypeEvent,
	strings.ToLower(_DeclarationTypeName[34:39]): DeclarationTypeEvent,
	_DeclarationTypeName[39:44]:                  DeclarationTypeError,
	strings.ToLower(_DeclarationTypeName[39:44]): DeclarationTypeError,
}

// ParseDeclarationType attempts to convert a string to a DeclarationType
func ParseDeclarationType(name string) (DeclarationType, error) {
	if x, ok := _DeclarationTypeValue[name]; ok {
		return x, nil
	}
	return DeclarationType(0), fmt.Errorf("%s is not a valid DeclarationType, try [%s]", name, strings.Join(_DeclarationTypeNames, ", "))
}

// MarshalText implements the text marshaller method
func (x DeclarationType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *DeclarationType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseDeclarationType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
